$ErrorActionPreference = "Stop"

function Require-File {
    param(
        [Parameter(Mandatory = $true)][string]$Path,
        [Parameter(Mandatory = $true)][string]$Label
    )

    if (-not (Test-Path -LiteralPath $Path -PathType Leaf)) {
        throw "$Label is missing: $Path"
    }
}

function Invoke-Native {
    param(
        [Parameter(Mandatory = $true)][string]$Exe,
        [Parameter(Mandatory = $true)][string[]]$Args
    )

    $output = & $Exe @Args 2>&1
    $exitCode = $LASTEXITCODE
    if ($exitCode -ne 0) {
        $rendered = ($output | ForEach-Object { $_.ToString() }) -join " "
        throw "command failed (exit=$exitCode): $Exe $($Args -join ' ') $rendered"
    }

    return ,$output
}

try {
    $leoRoot = Split-Path -Parent $PSScriptRoot
    $leoExe = Join-Path $leoRoot "leo.exe"
    $cupolaExe = Join-Path $leoRoot "tools\cupola\cupola-cli.exe"
    $aegisExe = Join-Path $leoRoot "tools\aegis\aegis.exe"
    $epiExe = Join-Path $leoRoot "tools\epi\epi-cli.exe"
    $configPath = Join-Path $leoRoot "config\leo.toml"

    $dataDir = Join-Path $leoRoot "data"
    $intakePath = Join-Path $dataDir "intake.json"
    $fallbackIntake = Join-Path $leoRoot "tools\aegis\data\intake.json"

    Require-File -Path $leoExe -Label "leo.exe"
    Require-File -Path $cupolaExe -Label "cupola-cli.exe"
    Require-File -Path $aegisExe -Label "aegis.exe"
    Require-File -Path $epiExe -Label "epi-cli.exe"
    Require-File -Path $configPath -Label "config\\leo.toml"

    if (-not (Test-Path -LiteralPath $intakePath -PathType Leaf)) {
        if (-not (Test-Path -LiteralPath $fallbackIntake -PathType Leaf)) {
            throw "intake.json is missing from dist data folder and fallback path: $fallbackIntake"
        }
        New-Item -ItemType Directory -Path $dataDir -Force | Out-Null
        Copy-Item -LiteralPath $fallbackIntake -Destination $intakePath -Force
    }

    Require-File -Path $intakePath -Label "data\\intake.json"

    $stamp = Get-Date -Format "yyyyMMdd-HHmmss"
    $smokeRoot = Join-Path $env:TEMP "leo-smoke"
    $vaultRoot = Join-Path $smokeRoot "vault"
    $vaultDir = Join-Path $vaultRoot ("synthetic-" + $stamp)
    $outDir = Join-Path $smokeRoot ("run-" + $stamp)
    $appDataDir = Join-Path $smokeRoot ("appdata-" + $stamp)
    $cupolaRepo = Join-Path $smokeRoot ("cupola-repo-" + $stamp)
    $cupolaProxySrc = Join-Path $cupolaRepo "cupola-cli\src"
    $cupolaProxyExe = Join-Path $cupolaRepo "target\release\cupola-cli.exe"

    New-Item -ItemType Directory -Path $vaultDir -Force | Out-Null
    New-Item -ItemType Directory -Path (Join-Path $vaultDir "notes") -Force | Out-Null
    New-Item -ItemType Directory -Path (Join-Path $vaultDir "evidence") -Force | Out-Null
    New-Item -ItemType Directory -Path $appDataDir -Force | Out-Null
    New-Item -ItemType Directory -Path $cupolaProxySrc -Force | Out-Null

    Set-Content -LiteralPath (Join-Path $vaultDir "README.md") -Value @"
# Synthetic Vault

This vault is generated by smoke_e2e.ps1 for LEO portable validation.
"@

    Set-Content -LiteralPath (Join-Path $vaultDir "notes\summary.txt") -Value @"
control: MFA enabled for privileged users
control: quarterly access review completed
"@

    Set-Content -LiteralPath (Join-Path $vaultDir "evidence\controls.json") -Value @"
{
  "controls": [
    {
      "id": "AC-01",
      "status": "implemented",
      "owner": "security"
    },
    {
      "id": "AC-02",
      "status": "monitoring",
      "owner": "platform"
    }
  ]
}
"@

    $packZip = Join-Path $outDir "pack.zip"
    Set-Content -LiteralPath (Join-Path $cupolaRepo "Cargo.toml") -Value @"
[workspace]
members = ["cupola-cli"]
resolver = "2"
"@

    Set-Content -LiteralPath (Join-Path $cupolaRepo "cupola-cli\Cargo.toml") -Value @"
[package]
name = "cupola-cli"
version = "0.0.0"
edition = "2021"
"@

    Set-Content -LiteralPath (Join-Path $cupolaProxySrc "main.rs") -Value @"
use std::env;
use std::process::{Command, exit};

fn main() {
    let target = match env::var("LEO_CUPOLA_EXE") {
        Ok(value) if !value.trim().is_empty() => value,
        _ => {
            eprintln!("LEO_CUPOLA_EXE is not set");
            exit(1);
        }
    };

    let status = match Command::new(target).args(env::args().skip(1)).status() {
        Ok(value) => value,
        Err(err) => {
            eprintln!("failed to execute bundled cupola-cli: {err}");
            exit(1);
        }
    };

    match status.code() {
        Some(code) => exit(code),
        None => exit(1),
    }
}
"@

    Push-Location $cupolaRepo
    try {
        Invoke-Native -Exe "cargo" -Args @("build", "--release") | Out-Null
    }
    finally {
        Pop-Location
    }

    Require-File -Path $cupolaProxyExe -Label "cupola proxy binary"

    $appDataWasSet = Test-Path Env:APPDATA
    $originalAppData = $env:APPDATA
    $cupolaExeWasSet = Test-Path Env:LEO_CUPOLA_EXE
    $originalCupolaExe = $env:LEO_CUPOLA_EXE
    $env:APPDATA = $appDataDir
    $env:LEO_CUPOLA_EXE = $cupolaExe

    Push-Location $leoRoot
    try {
        Invoke-Native -Exe $leoExe -Args @("doctor") | Out-Null
        Invoke-Native -Exe $leoExe -Args @(
            "run",
            "--vault", $vaultDir,
            "--intake", $intakePath,
            "--out", $outDir,
            "--cupola-bin", $cupolaProxyExe
        ) | Out-Null
        $verifyOutput = Invoke-Native -Exe $epiExe -Args @("verify", $packZip, "--json")
    }
    finally {
        Pop-Location
        if ($cupolaExeWasSet) {
            $env:LEO_CUPOLA_EXE = $originalCupolaExe
        }
        else {
            Remove-Item Env:LEO_CUPOLA_EXE -ErrorAction SilentlyContinue
        }
        if ($appDataWasSet) {
            $env:APPDATA = $originalAppData
        }
        else {
            Remove-Item Env:APPDATA -ErrorAction SilentlyContinue
        }
    }

    $verifyRaw = (($verifyOutput | ForEach-Object { $_.ToString() }) -join "`n").Trim()
    if ([string]::IsNullOrWhiteSpace($verifyRaw)) {
        throw "epi verify returned empty JSON output"
    }

    $verifyObject = $verifyRaw | ConvertFrom-Json
    $verifyJson = $verifyObject | ConvertTo-Json -Compress -Depth 64
    Write-Output "PASS $verifyJson"
    exit 0
}
catch {
    Write-Output "FAIL $($_.Exception.Message)"
    exit 1
}
